### 작업 지시: JWT 인증 시스템 전환 및 블랙리스트 구현

목표: 기존 데스크톱 앱의 인증 방식을 URL 리다이렉션 기반 세션 ID 방식에서, 보안 및 확장성이 우수한 JWT 기반 인증 시스템으로 전환한다.

---

### 1. `token_blacklist` 테이블 생성 및 JWT 활성화

- 테이블 생성: PostgreSQL에 `token_blacklist` 테이블 생성.
    
    - `jti`: `VARCHAR(255)` 타입, JWT의 고유 식별자(JTI)를 저장하는 Primary Key.
        
    - `expires_at`: `TIMESTAMP` 타입, 해당 토큰이 만료되는 시간.
        
    - `created_at`: `TIMESTAMP` 타입, 레코드 생성 시간.
        
- JWT 라이브러리 설치 및 설정: NestJS 프로젝트에 `@nestjs/jwt` 및 `passport-jwt` 설치. `JwtModule`과 `JwtStrategy`를 설정하여 JWT 기반 인증 활성화.
    

---

### 2. NestJS 백엔드 로직 수정

- 응답 방식 변경: `googleCallbackDesktop` 컨트롤러의 리다이렉션 로직을 제거한다. 대신 사용자 인증 후, `accessToken`**과 **`refreshToken`**을 생성하여 JSON 응답 본문에 포함해 반환하도록 수정한다.
    
- 새로운 API 구현:
    
    - 로그아웃 엔드포인트: `POST /auth/logout` 엔드포인트를 구현. 요청 헤더의 `Authorization` 토큰을 파싱하여 `jti`와 `expires_at`를 추출, `token_blacklist` 테이블에 삽입.
        
    - 토큰 갱신 엔드포인트: `POST /auth/refresh` 엔드포인트를 구현. 클라이언트로부터 `refreshToken`을 받아 유효성 검증 후, 새로운 `accessToken`과 `refreshToken`을 발급하여 반환.
        
    - 토큰 검증 로직: 모든 `private` API 요청에 대한 가드를 수정. 토큰 만료 여부와 함께 `token_blacklist` 테이블에 해당 `jti`가 존재하는지 확인하는 로직 추가.
        

---

### 3. 클라이언트(Electron) 로직 수정

- 로그인 처리 로직: 로그인 후 서버로부터 `accessToken`과 `refreshToken`을 포함한 JSON 응답을 받아, 이를 Electron의 `safeStorage` API를 통해 안전하게 저장.
    
- API 요청 방식 변경: 모든 API 호출 시 `accessToken`을 URL 쿼리가 아닌 요청 헤더의 `Authorization` 필드에 포함시켜 전송.
    
- 로그아웃 로직: 사용자가 로그아웃하면 `logout` API를 호출하여 서버에 토큰 무효화를 요청하고, 클라이언트의 `safeStorage`에서 저장된 토큰 삭제.
    
- 토큰 갱신 로직: `accessToken`이 만료되었을 때 `refresh` API를 호출하여 새로운 토큰을 발급받고 저장하는 로직 추가.