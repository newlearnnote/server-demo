# 2025.11.18 개발 노트 - 북마크 시스템 완성

## 📋 오늘 작업 내용

### 1. 북마크 시스템 완전 구현 ✅

#### 1.1 토글 방식 북마크 기능

- **통합 엔드포인트**: `POST /api/desktop-app/bookmarks/toggle`
- **동작 방식**: 북마크가 없으면 생성, 있으면 삭제 (Soft Delete)
- **Soft Delete 방식**: `deletedAt` 필드로 논리적 삭제 구현
- **재활성화 로직**: 삭제된 북마크가 있으면 새로 생성하지 않고 `deletedAt: null`로 복구

#### 1.2 구현된 엔드포인트

```typescript
// 데스크톱 앱용 북마크 컨트롤러
@Controller('desktop-app/bookmarks')
@UseGuards(JwtDesktopAuthGuard)
export class NoteBookmarkAppController {
  @Post()  // POST /api/desktop-app/bookmarks
  async toggleBookmark(@Request() req, @Body() dto: CreateBookmarkDto)
}

// 웹용 북마크 컨트롤러
@Controller('web/bookmarks')
export class NoteBookmarkWebController {
  @Post('toggle')  // POST /api/web/bookmarks/toggle
  async toggleBookmark(@Request() req, @Body() dto: CreateBookmarkDto)
}
```

### 2. Google OAuth 문제 해결 ✅

#### 2.1 문제 상황

```
로그 오류: GET /api/auth/google/callback/desktop - 404 오류
실제 컨트롤러: /api/desktop-app/auth/google/callback
```

#### 2.2 해결 과정

1. **문제 발견**: Google Strategy의 콜백 URL과 컨트롤러 경로 불일치
2. **해결 방법**: 환경변수 수정

   ```env
   # 수정 전
   GOOGLE_CALLBACK_DESKTOPAPP_URL=http://localhost:8000/api/auth/google/callback/desktop

   # 수정 후
   GOOGLE_CALLBACK_DESKTOPAPP_URL=http://localhost:8000/api/desktop-app/auth/google/callback
   ```

### 3. 🔥 북마크 카운트 동기화 문제 해결 (핵심 난제)

#### 3.1 문제 상황

- **증상**: 북마크 삭제 시 카운트가 -1로 표시되는 현상
- **원인**: Soft Delete와 increment/decrement 방식의 충돌

#### 3.2 문제 분석

```typescript
// 문제가 된 시나리오
1. 첫 북마크: count 0 → 1 (increment +1) ✅
2. 삭제: count 1 → 0 (decrement -1) ✅
3. 재북마크: 기존 북마크 재활성화 + increment +1 → count 1 ✅
4. 다시 삭제: decrement -1 → count 0이지만...
   실제로는 increment가 중복 실행되어 count가 틀어짐 ❌

// 근본 원인
- createWithTransaction: 재활성화 시에도 increment +1 실행
- deleteWithTransaction: 항상 decrement -1 실행
- 결과: 중복 계산으로 카운트 불일치
```

#### 3.3 해결 방법: 실제 개수 기반 동기화

```typescript
// ❌ 기존 방식 (increment/decrement)
await prisma.note.update({
  data: {
    bookmarkCount: { increment: 1 }, // 틀어질 수 있음
  },
});

// ✅ 새로운 방식 (실제 카운트 동기화)
const actualCount = await prisma.noteBookmark.count({
  where: {
    noteId: data.noteId,
    deletedAt: null, // 살아있는 북마크만
  },
});

await prisma.note.update({
  data: {
    bookmarkCount: actualCount, // 항상 정확한 값
  },
});
```

#### 3.4 Repository 메서드 수정 사항

```typescript
// 1. createWithTransaction 수정
async createWithTransaction(data: { userId: string; noteId: string }) {
  return this.prisma.$transaction(async (prisma) => {
    // 기존 삭제된 북마크 확인
    const existingBookmark = await prisma.noteBookmark.findFirst({
      where: { userId: data.userId, noteId: data.noteId }
    });

    let bookmark;
    if (existingBookmark && existingBookmark.deletedAt) {
      // 재활성화: deletedAt을 null로 변경
      bookmark = await prisma.noteBookmark.update({
        where: { id: existingBookmark.id },
        data: { deletedAt: null }
      });
    } else {
      // 새로 생성
      bookmark = await prisma.noteBookmark.create({ data });
    }

    // 실제 개수로 동기화
    const actualCount = await prisma.noteBookmark.count({
      where: { noteId: data.noteId, deletedAt: null }
    });

    await prisma.note.update({
      where: { id: data.noteId },
      data: { bookmarkCount: actualCount }
    });

    return bookmark;
  });
}

// 2. deleteWithTransaction 수정
async deleteWithTransaction(bookmarkId: string, noteId: string) {
  await this.prisma.$transaction(async (prisma) => {
    // Soft Delete
    await prisma.noteBookmark.update({
      where: { id: bookmarkId },
      data: { deletedAt: new Date() }
    });

    // 실제 개수로 동기화
    const actualCount = await prisma.noteBookmark.count({
      where: { noteId: noteId, deletedAt: null }
    });

    await prisma.note.update({
      where: { id: noteId },
      data: { bookmarkCount: actualCount }
    });
  });
}
```

#### 3.5 Soft Delete 조건 추가

모든 조회 메서드에 `deletedAt: null` 조건 추가:

```typescript
// findByUserAndNote, exists, findManyByUser, findRecentByUser 등
where: {
  userId,
  noteId,
  deletedAt: null  // 삭제되지 않은 것만
}
```

### 4. 카운트 불일치가 발생할 수 있는 케이스들

#### 4.1 위험한 메서드들

```typescript
// ❌ 물리적 삭제 (카운트 업데이트 없음)
async deleteByUserAndNote() {
  return this.prisma.noteBookmark.delete({ where: { id } });
}

// ❌ Soft Delete이지만 카운트 업데이트 없음
async deleteById(id: string) {
  return this.prisma.noteBookmark.update({
    data: { deletedAt: new Date() }
  });
}
```

#### 4.2 동시성 문제

- 여러 사용자가 동시에 같은 노트 북마크 시 Race Condition 가능
- 트랜잭션으로 어느 정도 해결되지만 완전하지 않음

#### 4.3 관리자 도구나 직접 DB 조작

- 북마크 테이블 직접 수정 시 카운트 불일치
- 주기적 검증 배치 작업 필요

### 5. 데이터 구조 및 아키텍처

#### 5.1 Repository Pattern 적용

```
Controller → Service → Repository → Database
```

#### 5.2 DTO 구조

```typescript
// 요청 DTO
export class CreateBookmarkDto {
  noteId: string; // 북마크할 노트 ID만 필요
}

// 응답 DTO
export class ResponseBookmarkDto {
  id: string;
  userId: string;
  noteId: string;
  note?: NoteInfo; // 노트 정보 (선택적)
  isBookmarked: boolean; // 현재 북마크 상태
  message: string; // 응답 메시지
  createdAt?: Date;
  updatedAt?: Date;
  deletedAt?: Date | null;
}
```

#### 5.3 데이터베이스 스키마

```prisma
model NoteBookmark {
  id        String   @id @default(cuid())
  userId    String
  noteId    String
  createdAt DateTime @default(now())
  deletedAt DateTime?  // Soft Delete용

  user User @relation(fields: [userId], references: [id])
  note Note @relation(fields: [noteId], references: [id])

  @@unique([userId, noteId])  // 중복 북마크 방지
}
```

### 6. 테스트 및 검증

#### 6.1 Postman 테스트

```
POST http://localhost:8000/api/desktop-app/bookmarks
Headers:
  - Content-Type: application/json
  - Authorization: Bearer JWT_TOKEN
Body:
{
  "noteId": "existing_note_id"
}
```

#### 6.2 시나리오 테스트

1. 첫 북마크 생성
2. 북마크 삭제 (Soft Delete)
3. 재북마크 (재활성화)
4. 카운트 정확성 검증

## 🔍 핵심 학습 포인트

### 1. Soft Delete의 복잡성

- 단순히 `deletedAt` 필드만 추가하면 끝이 아님
- 모든 조회 로직에 `deletedAt: null` 조건 필요
- 카운트 계산 시 특별한 주의 필요

### 2. 카운트 동기화 전략

- **Increment/Decrement**: 빠르지만 불일치 위험
- **실제 개수 계산**: 느리지만 항상 정확
- **트레이드오프**: 성능 vs 정확성

### 3. Repository Pattern의 중요성

- 비즈니스 로직과 데이터 접근 로직 분리
- 일관된 데이터 조작 보장
- 유지보수성 향상

### 4. 트랜잭션의 활용

```typescript
// 북마크 생성/삭제와 카운트 업데이트를 원자적으로 처리
await this.prisma.$transaction(async (prisma) => {
  // 1. 북마크 조작
  // 2. 카운트 계산
  // 3. 노트 업데이트
  // → 모두 성공하거나 모두 실패
});
```

## 🚀 다음 작업 계획

1. **댓글 시스템 구현**
   - 북마크 시스템과 유사한 구조 적용
   - Soft Delete 및 카운트 동기화 고려
2. **API 문서화 완성**
   - docs.md 업데이트
3. **배치 작업 구현**
   - 주기적 카운트 검증 및 수정 스크립트

## ⚠️ 주의사항

1. **deleteByUserAndNote, deleteById 메서드 사용 금지**
   - 반드시 `deleteWithTransaction` 사용
2. **직접 DB 조작 시 카운트 동기화 필수**
3. **새로운 기능 추가 시 Soft Delete 조건 확인**

## 🎯 성과

- 북마크 시스템 완전 동작
- Google OAuth 로그인 해결
- 카운트 불일치 문제 해결
- Repository Pattern 적용
- Soft Delete 완전 구현
